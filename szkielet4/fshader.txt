#version 330

//Zmienne jednorodne
uniform sampler2D textureMap0;
uniform sampler2D textureMap1;
uniform float shininess; //Polyskliwosc materialu

//Zmienne wyjsciowe z vertex shadera
in vec2 iTexCoord;
in vec4 lgPos1;
in vec4 lgPos2;
in vec4 n;
in vec4 v;

out vec4 pixelColor; //Zmienna wyjsciowa fragment shadera

void main(void){
	vec4 lgPos1N = normalize(lgPos1);
	vec4 lgPos2N = normalize(lgPos2);
	vec4 nN = normalize(n);
	vec4 vN = normalize(v);
	
	vec4 r[2];
	float nl[2];
	float rv[2];

	vec4 La = vec4(0.5, 0.5, 0.5, 0.5); //Kolor swiatla otoczenia
	vec4 Ma = texture(textureMap0, iTexCoord); //Kolor materialu dla swiatla otoczenia

	vec4 Ld = vec4(0.7, 0.7, 0.7, 1); //Kolor swiatla rozpraszanego
	vec4 Md = texture(textureMap0, iTexCoord); //Kolor materialu dla swiatla rozpraszanego

	vec4 Ls = vec4(1, 1, 1, 1);	//Kolor swiatla odbijanego
	vec4 Ms = texture(textureMap1, iTexCoord); //Kolor materialu dla swiatla rozpraszanego

	r[0] = reflect(-lgPos1N, nN);
	r[1] = reflect(-lgPos2N, nN);

	nl[0] = max(dot(lgPos1N, nN), 0);
	nl[1] = max(dot(lgPos2N, nN), 0);

	rv[0] = max(dot(r[0], vN), 0);
	rv[1] = max(dot(r[1], vN), 0);

	pixelColor = La*Ma + Ld*Md*vec4(vec3(max(nl[0], nl[1])), 1) + Ls*Ms*pow(max(rv[0], rv[1]),shininess);
}

















/*
void main(void) {
	//Parametry modelu oswietlenia
	vec4 La = vec4(0.4,0.4,0.4,1); //Kolor swiatla otoczenia
	vec4 Ma = texture(textureMap0, iTexCoord); //Kolor materialu dla swiatla otoczenia

	vec4 Ld = vec4(0.25,0.25,0.25,1); //Kolor swiatla rozpraszanego
	vec4 Md = texture(textureMap1, iTexCoord); //Kolor materialu dla swiatla rozpraszanego

	vec4 Ls = vec4(1,1,1,1); //Kolor swiatla odbijanego
	vec4 Ms = texture(textureMap1, iTexCoord); //Kolor materialu dla swiatla odbijanego

	int i;
	vec4 ml[lightscount];
	vec4 mr[lightscount];

	//Wektory potrzebne do obliczenia modelu oswietlenia
	vec4 mn = normalize(n);
	for(i = 0; i < lightscount; i++) {
		ml[i] = normalize(l[i]);
		mr[i] = reflect(-ml[i], mn);
	}
	vec4 mv = normalize(v);

	float nl[lightscount];
	float rv[lightscount];

	pixelColor = vec4(0,0,0,1);

	//Obliczenie modelu oswietlenia
	for(i = 0; i < lightscount; i++) {
		nl[i] = max(dot(ml[i], mn),0);
		rv[i] = pow(max(dot(mr[i], mv),0), shininess);
		if(pixelColor != vec4(1,1,1,1))
			pixelColor += Ld*Md*vec4(nl[i],nl[i],nl[i],1) + Ls*Ms*vec4(rv[i],rv[i],rv[i],0);
	}
	
	if(pixelColor != vec4(1,1,1,1))
		pixelColor += La*Ma;
}
*/